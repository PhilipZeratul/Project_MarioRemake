{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red113\green157\blue207;\red238\green238\blue236;\red138\green226\blue50;
\red229\green218\blue115;\red120\green151\blue105;}
{\*\expandedcolortbl;;\csgenericrgb\c44314\c61569\c81176;\csgenericrgb\c93333\c93333\c92549;\csgenericrgb\c54118\c88627\c19608;
\csgenericrgb\c89804\c85490\c45098;\csgenericrgb\c47059\c59216\c41176;}
\paperw11900\paperh16840\margl1440\margr1440\vieww18280\viewh14720\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 using\cf3  UnityEngine;\uc0\u8232 \u8232 \u8232 \cf2 public\cf3  \cf2 class\cf3  PhysicsObject : MonoBehaviour\uc0\u8232 \{\u8232     \cf2 public\cf3  \cf2 float\cf3  horizontalSpeed = \cf4 8f\cf3 ;\uc0\u8232     \cf2 public\cf3  \cf2 float\cf3  jumpSpeed = \cf4 8f\cf3 ;\uc0\u8232     \cf2 public\cf3  \cf2 float\cf3  gravityScale = \cf4 1f\cf3 ;\uc0\u8232     \cf2 public\cf3  LayerMask whatIsGround;\uc0\u8232 \u8232     \cf2 protected\cf3  \cf2 bool\cf3  isGrounded = \cf2 false\cf3 ;\uc0\u8232     \cf2 protected\cf3  \cf2 bool\cf3  wasGrounded = \cf2 false\cf3 ;\uc0\u8232     \cf2 protected\cf3  \cf2 float\cf3  fixedDeltaTime;\uc0\u8232 \u8232     \cf2 private\cf3  Rigidbody2D rb2d;\uc0\u8232     \cf2 private\cf3  RaycastHit2D[] raycastHit2Ds = \cf2 new\cf3  RaycastHit2D[\cf4 16\cf3 ];\uc0\u8232     \cf2 private\cf3  ContactFilter2D contactFilter2D;\uc0\u8232     \cf2 private\cf3  Vector2 velocity;\uc0\u8232     \cf2 private\cf3  \cf2 float\cf3  minCollisionNormal = \cf4 0.9f\cf3 ;\uc0\u8232     \cf2 private\cf3  \cf2 float\cf3  collisionShell = \cf4 0.02f\cf3 ;\uc0\u8232     \cf2 private\cf3  \cf2 float\cf3  skinSpace = \cf4 0.005f\cf3 ;\uc0\u8232 \u8232 \u8232     \cf2 private\cf3  \cf2 void\cf3  Awake()\uc0\u8232     \{\u8232         rb2d = GetComponent<Rigidbody2D>();\u8232 \u8232         contactFilter2D.useTriggers = \cf2 false\cf3 ;\uc0\u8232         contactFilter2D.SetLayerMask(Physics2D.GetLayerCollisionMask(gameObject.layer));\u8232         contactFilter2D.useLayerMask = \cf2 true\cf3 ;\uc0\u8232 \u8232         \cf2 if\cf3  (whatIsGround == \cf4 0\cf3 )\uc0\u8232             Debug.LogWarning(\cf5 "Please set whatIsGround property."\cf3 );\uc0\u8232     \}\u8232 \u8232     \cf2 private\cf3  \cf2 void\cf3  FixedUpdate()\uc0\u8232     \{\u8232         fixedDeltaTime = Time.deltaTime;\u8232 \u8232         \cf2 float\cf3  horizontalV = CalcHorizontalVelocity();\uc0\u8232         \cf2 float\cf3  verticalV = CalcVerticalVelocity() + gravityScale * Physics2D.gravity.y * fixedDeltaTime;\uc0\u8232 \u8232         velocity = \cf2 new\cf3  Vector2(horizontalV, velocity.y + verticalV);\uc0\u8232 \u8232         CollisionCheck();\u8232 \u8232         Move();\u8232     \}\u8232 \u8232     \cf2 protected\cf3  \cf2 virtual\cf3  \cf2 float\cf3  CalcHorizontalVelocity()\uc0\u8232     \{\u8232         \cf2 return\cf3  \cf4 0f\cf3 ;\uc0\u8232     \}\u8232 \u8232     \cf2 protected\cf3  \cf2 virtual\cf3  \cf2 float\cf3  CalcVerticalVelocity()\uc0\u8232     \{\u8232         \cf2 return\cf3  \cf4 0f\cf3 ;\uc0\u8232     \}\u8232 \u8232     \cf2 private\cf3  \cf2 void\cf3  CollisionCheck()\uc0\u8232     \{\u8232         wasGrounded = isGrounded;\u8232         isGrounded = \cf2 false\cf3 ;\uc0\u8232 \u8232         \cf2 float\cf3  newPositionX = rb2d.position.x;\uc0\u8232         \cf2 float\cf3  newPositionY = rb2d.position.y;\uc0\u8232 \u8232         \cf6 //float distance = velocity.magnitude * fixedDeltaTime + collisionShell;\uc0\u8232 \u8232 \cf3         \cf2 float\cf3  distanceX = velocity.x * fixedDeltaTime + collisionShell;\uc0\u8232         \cf2 float\cf3  distanceY = velocity.y * fixedDeltaTime + collisionShell;\uc0\u8232 \u8232         \cf2 int\cf3  countX = rb2d.Cast(\cf2 new\cf3  Vector2(velocity.x, \cf4 0f\cf3 ), contactFilter2D, raycastHit2Ds, distanceX);\uc0\u8232         Debug.LogFormat(\cf5 "CollisionCheck(), countX = \{0\}"\cf3 , countX);\uc0\u8232 \u8232         \cf2 for\cf3  (\cf2 int\cf3  i = \cf4 0\cf3 ; i < countX; i++)\uc0\u8232         \{\u8232             Debug.LogFormat(\cf5 "Horizontal Collision, distance = \{0\}, normal = \{1\}, point = \{2\}"\cf3 , raycastHit2Ds[i].distance.ToString(\cf5 "F4"\cf3 ), raycastHit2Ds[i].normal.ToString(\cf5 "F4"\cf3 ), raycastHit2Ds[i].point.ToString(\cf5 "F4"\cf3 ));\uc0\u8232             \cf6 // Horizontal Collision.\uc0\u8232 \cf3             \cf2 if\cf3  (-raycastHit2Ds[i].normal.x * Mathf.Sign(velocity.x) > minCollisionNormal)\uc0\u8232             \{\u8232                 velocity = \cf2 new\cf3  Vector2(\cf4 0f\cf3 , velocity.y);\uc0\u8232                 newPositionX = Mathf.Round(raycastHit2Ds[i].point.x) + Mathf.Sign(raycastHit2Ds[i].normal.x) * (\cf4 0.5f\cf3  + skinSpace);\uc0\u8232             \}\u8232         \}\u8232 \u8232 \u8232         \cf2 int\cf3  countY = rb2d.Cast(\cf2 new\cf3  Vector2(\cf4 0f\cf3 , velocity.y), contactFilter2D, raycastHit2Ds, distanceY);\uc0\u8232         Debug.LogFormat(\cf5 "CollisionCheck(), countY = \{0\}"\cf3 , countY);\uc0\u8232 \u8232         \cf2 for\cf3  (\cf2 int\cf3  i = \cf4 0\cf3 ; i < countY; i++)\uc0\u8232         \{\u8232             \cf6 // Collide with ground.\uc0\u8232 \cf3             \cf2 if\cf3  (whatIsGround == (whatIsGround | (\cf4 1\cf3  << raycastHit2Ds[i].collider.gameObject.layer)))\uc0\u8232             \{\u8232                 \cf6 // Vertical Down collision.\uc0\u8232 \cf3                 \cf2 if\cf3  (velocity.y < \cf4 0\cf3  && raycastHit2Ds[i].normal.y > minCollisionNormal)\uc0\u8232                 \{\u8232                     Debug.Log(\cf5 "Down Collision."\cf3 );\uc0\u8232                     isGrounded = \cf2 true\cf3 ;\uc0\u8232                     velocity = \cf2 new\cf3  Vector2(velocity.x, \cf4 0f\cf3 );\uc0\u8232                     \cf2 if\cf3  (!wasGrounded)\uc0\u8232                     \{\u8232                         \cf6 // Round the final y position, so that character wouldn't stuck in ground.\uc0\u8232 \cf3                         newPositionY = Mathf.Round(raycastHit2Ds[i].point.y) + skinSpace;\uc0\u8232                         OnLanded();\u8232                     \}\u8232                 \}\u8232                 \cf6 // Vertical Up collision.\uc0\u8232 \cf3                 \cf2 else\cf3  \cf2 if\cf3  (velocity.y > \cf4 0\cf3  && -raycastHit2Ds[i].normal.y > minCollisionNormal)\uc0\u8232                 \{\u8232                     Debug.Log(\cf5 "Up Collision."\cf3 );\uc0\u8232                     velocity = \cf2 new\cf3  Vector2(velocity.x, \cf4 0f\cf3 );\uc0\u8232                     newPositionY = rb2d.position.y - raycastHit2Ds[i].distance * raycastHit2Ds[i].normal.y;\u8232                 \}\u8232             \}\u8232         \}\u8232 \u8232         rb2d.position = \cf2 new\cf3  Vector2(newPositionX, newPositionY);\uc0\u8232     \}\u8232 \u8232     \cf2 private\cf3  \cf2 void\cf3  Move()\uc0\u8232     \{\u8232         Debug.LogFormat(\cf5 "velocity = \{0\}"\cf3 , velocity);\uc0\u8232         rb2d.velocity = velocity;\u8232 \u8232         \cf6 //Debug.LogFormat("velocity = \{0\}", velocity.ToString("F4"));\uc0\u8232 \cf3         \cf6 //rb2d.MovePosition(rb2d.position += velocity * fixedDeltaTime);\uc0\u8232 \cf3     \}\uc0\u8232 \u8232     \cf2 protected\cf3  \cf2 virtual\cf3  \cf2 void\cf3  OnLanded()\uc0\u8232     \{\u8232     \}\u8232 \}\u8232 \u8232 }